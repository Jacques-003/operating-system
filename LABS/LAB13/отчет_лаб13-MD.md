**РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ**

**Факультет физико-математических и естественных наук**

**Кафедра прикладной информатики и теории вероятностей**





**ОТЧЕТ** 

**ПО ЛАБОРАТОРНОЙ РАБОТЕ № 13**	

*дисциплина:	Операционные системы*	 









Студент: Ниемек Яи Жак                                    

`	`Группа: НММБд-04-24                                       







**МОСКВА**

2025	 г.

Цель работы

Изучить основы программирования в оболочке ОС UNIX. Научится писать более сложные командные файлы с использованием логических управляющих конструкций и циклов.

**Последовательность выполнения работы**

1\. Используя команды getopts grep, написать командный файл, который анализирует

командную строку с ключами:

– -iinputfile — прочитать данные из указанного файла;

– -ooutputfile — вывести данные в указанный файл;

– -pшаблон — указать шаблон для поиска;

– -C — различать большие и малые буквы;

– -n — выдавать номера строк.

а затем ищет в указанном файле нужные строки, определяемые ключом -p.

2\. Написать на языке Си программу, которая вводит число и определяет, является ли оно

больше нуля, меньше нуля или равно нулю. Затем программа завершается с помощью

функции exit(n), передавая информацию в о коде завершения в оболочку. Командный файл должен вызывать эту программу и, проанализировав с помощью команды

$?, выдать сообщение о том, какое число было введено.

3\. Написать командный файл, создающий указанное число файлов, пронумерованных

последовательно от 1 до 𝑁 (например 1.tmp, 2.tmp, 3.tmp,4.tmp и т.д.). Число файлов,

которые необходимо создать, передаётся в аргументы командной строки. Этот же командный файл должен уметь удалять все созданные им файлы (если они существуют).

4\. Написать командный файл, который с помощью команды tar запаковывает в архив

все файлы в указанной директории. Модифицировать его так, чтобы запаковывались

только те файлы, которые были изменены менее недели тому назад (использовать

команду find).


![](Aspose.Words.970a9a14-3583-40c4-844c-bc95559daec0.001.png "1")












![](Aspose.Words.970a9a14-3583-40c4-844c-bc95559daec0.002.png "2")


















![](Aspose.Words.970a9a14-3583-40c4-844c-bc95559daec0.003.png "3")



![](Aspose.Words.970a9a14-3583-40c4-844c-bc95559daec0.004.png "4")	













![](Aspose.Words.970a9a14-3583-40c4-844c-bc95559daec0.005.png "5")













![](Aspose.Words.970a9a14-3583-40c4-844c-bc95559daec0.006.png "6")	










\---

\### 1. Предназначение команды getopts

\* Используется для разбора аргументов командной строки с ключами (опциями).

\* Позволяет удобно обрабатывать флаги -a, -b value и т.д.

while getopts "i:o:p:Cn" opt; do

`  `case $opt in

`    `i) inputfile=$OPTARG ;;

`    `o) outputfile=$OPTARG ;;

`  `esac

done

\---

\### 2. Метасимволы и генерация имён файлов

\* Метасимволы (`\*`, ?, `[ ]`) позволяют создавать шаблоны для поиска или подстановки имён файлов.

ls \*.txt     # все файлы с расширением .txt

ls file?.sh  # file1.sh, file2.sh и т.д.

\---

\### 3. Операторы управления действиями

\* ; – последовательное выполнение команд

\* && – выполнить вторую команду, если первая успешна

\* || – выполнить вторую команду, если первая неудачна

\* & – выполнить команду в фоне

\---

\### 4. Операторы для прерывания цикла

\* break – выйти из текущего цикла полностью

\* continue – перейти к следующей итерации цикла

\---

\### 5. Назначение команд true и false

\* true – возвращает код 0 (успех), всегда истина

\* false – возвращает код 1 (ошибка), всегда ложь

\* Используются для условных конструкций или заглушек:

while true; do

`  `echo "Running..."

done

\---

\### 6. Разбор строки if test -f man$s/$i.$s

\* Проверяет существует ли файл с именем man$s/$i.$s.

\* -f – проверка на обычный файл.

\* Используется для условной обработки только существующих файлов.

\---

\### 7. Различия между while и until

| Конструкция         | Логика выполнения                                                   |

\| ------------------- | ------------------------------------------------------------------- |

| while [ условие ] | Выполняет цикл пока условие истинно                             |

| until [ условие ] | Выполняет цикл пока условие ложно (т.е. противоположно `while`) |

Пример:

\# while

count=0

while [ $count -lt 3 ]; do

`  `echo $count

`  `((count++))

done

\# until

count=0

until [ $count -ge 3 ]; do

`  `echo $count

`  `((count++))

done

Оба цикла выведут: 0 1 2


